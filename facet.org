The Big List of Facet TODOs

* Optimizer
** TODO Common subexpression elimination
    
  Without relying on the AST, that is.

** TODO cast chain optimization
float(float(x)) => float(x), 

float(x) => x, if x is known to be float

** TODO Generally, idempotent chain optimizations.

** TODO Logical expression optimizations

** TODO Initialization optimization for conditional expressions.
* Types
** TODO Function types
These will be useful when we have user-defined GLSL.

** TODO Loops of some kind. 

  Streams of value-generating expressions seem appropriate, since we
  can constrain the generator to be finite.

** TODO user-defined glsl

** TODO Invariance declarations

** TODO Typechecking code review 
functions like cosh which just build other expressions should have
stricter type checking.

* Documentation
** TODO NeHe Lessons
** TODO Change lesson2.html to reflect camera class.
* Expressions
** TODO ternary op performance fixes.
Right now the algorithm in place is correct, but conservative. Ideally,
I will want to propagate BDDs up the expression tree and check them

** TODO discard

Discard is a statement; I don't really have statements in the
language.


*** discard is fragment-only.

How do I implement discard in a vertex shader?

**** Possibilities:
***** Disallow it to happen in the vertex shader
Good: Simplest
Bad: Breaks the model in Facet programs where we don't care much about
what happens in vertex expressions vs fragment expressions
Ugly: The error messages would be really opaque, unless I specifically
detect where the discard statement would appear.
***** Send the vertex outside the homogenous cube
Good: Simple
Bad: doesn't discard the whole primitive
Ugly: would make triangles, etc look really weird.
***** Set some special varying which discards every single fragment in the shader
Good: Discards an entire primitive.
Bad: Wastes a varying, which might be a scarce resource.
Ugly: varying cannot be discrete (bool). The solution would be to
discard if varying is greater than zero, set the discarded varying to be greater
than the largest possible distance between two vertices on the screen,
and the non-discarded to zero.

*** Implementation ideas:

**** special key for the program description

like so:

{
  gl_Position: foo
  gl_FragColor: bar
  discard_if: baz
}

The main disadvantage here is that one application of discard is to
save computation time. This means that my current initialization of
variables used in more than one context will be wasteful if none of
these variables are actually used before the discard condition is
verified. What I would need, then, is some dependency analysis that
determines which variables are used for which discard checks, and
computes those in the correct order.

This discard interacts with the initializer code.

**** new expression called discard_if

We add a discard_when(condition, value_if_not) expression, which
issues the discard statement if condition is true. 

But what about discard_when being executed inside conditional
expressions? Worse: discard_when would turn case D above from a
performance problem into an actual bug.

** TODO precision declarations

* Rendering
* API
** TODO I really should have a matrix stack.
** TODO I should have a camera class

This class would expose Shade functions to perform transformations. A
cool demo would be a real non-linear fisheye distortion
projection. Obviously tesselation would be necessary, but it'd get the
point across.

** TODO There should be an API for strided attribute buffers.
The advantage here is that I could get different attributes from a
single bound array buffer. This would reduce the overhead of binding
the different attributes when switching state.

The main difficulty is that I currently
assume a one-to-one relationship between array buffers and attributes
throughout the API.
* Testing/Engineering
** TODO Write test suite for all builtins constant folding
I've been seeing a lot of infinite loops because of co-recursion in
constant_value. What do I do about it?

** TODO Typechecking code review 
functions like cosh which just build other expressions should have
stricter type checking.


** TODO Code review on FIXMEs
* Features
** Unprojecting
Since I can't read from the depth buffer, I need a WebGL unproject by
rendering the Z value into RGBA and reading back the same way as we do
picking.

** Multiple WebGL canvases in a same page
This means multiple contexts, and lots of things are going to break.
* Other
** FIXME what do we do on canvas resizing?
